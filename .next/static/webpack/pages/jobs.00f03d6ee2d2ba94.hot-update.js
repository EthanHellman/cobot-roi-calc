"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/jobs",{

/***/ "./src/utils/job-calculations.ts":
/*!***************************************!*\
  !*** ./src/utils/job-calculations.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateJobEfficiency: () => (/* binding */ calculateJobEfficiency),\n/* harmony export */   calculateShopEfficiency: () => (/* binding */ calculateShopEfficiency)\n/* harmony export */ });\nconst MINUTES_PER_HOUR = 60;\nfunction calculateSinglePartTime(length, passes, travelSpeed, efficiency, isManual) {\n    if (travelSpeed <= 0) throw new Error('Travel speed must be greater than 0');\n    if (efficiency <= 0) throw new Error('Efficiency must be greater than 0');\n    const baseTime = length * passes / travelSpeed;\n    return isManual ? baseTime / (efficiency / 100) : baseTime * (efficiency / 100);\n}\nfunction calculateJobEfficiency(job) {\n    const manual = {\n        weldTime: 0,\n        totalCycleTime: 0\n    };\n    const cobot = {\n        weldTime: 0,\n        totalCycleTime: 0\n    };\n    // Calculate total time for each part\n    job.parts.forEach((param)=>{\n        let { part, quantity } = param;\n        try {\n            // Calculate time for one part\n            const singlePartManualTime = calculateSinglePartTime(part.length, part.passes, part.manualTravelSpeed, part.manualEfficiency, true);\n            const singlePartCobotTime = calculateSinglePartTime(part.length, part.passes, part.cobotTravelSpeed, part.cobotEfficiency, false);\n            // Calculate total annual time for this part type\n            const totalPartsPerYear = quantity * job.annualDemand;\n            manual.weldTime += singlePartManualTime * totalPartsPerYear;\n            cobot.weldTime += singlePartCobotTime * totalPartsPerYear;\n        } catch (error) {\n            console.error(\"Error calculating times for part \".concat(part.name, \":\"), error);\n        // Continue with next part instead of failing completely\n        }\n    });\n    // Set total cycle times (currently just weld times, can be expanded)\n    manual.totalCycleTime = manual.weldTime;\n    cobot.totalCycleTime = cobot.weldTime;\n    // Calculate improvements (with safety checks)\n    const cycleTimeReduction = manual.totalCycleTime > 0 ? (manual.totalCycleTime - cobot.totalCycleTime) / manual.totalCycleTime * 100 : 0;\n    const laborTimeSaved = (manual.totalCycleTime - cobot.totalCycleTime) / MINUTES_PER_HOUR;\n    const throughputIncrease = cobot.totalCycleTime > 0 ? (manual.totalCycleTime / cobot.totalCycleTime - 1) * 100 : 0;\n    return {\n        manual,\n        cobot,\n        improvements: {\n            cycleTimeReduction: Math.max(0, cycleTimeReduction),\n            laborTimeSaved: Math.max(0, laborTimeSaved),\n            throughputIncrease: Math.max(0, throughputIncrease),\n            totalAnnualSavings: Math.max(0, laborTimeSaved)\n        }\n    };\n}\nfunction calculateShopEfficiency(jobs) {\n    if (!Array.isArray(jobs) || jobs.length === 0) {\n        return {\n            totalJobs: 0,\n            uniqueParts: 0,\n            totalAnnualParts: 0,\n            manual: {\n                totalWeldTime: 0,\n                totalCycleTime: 0\n            },\n            cobot: {\n                totalWeldTime: 0,\n                totalCycleTime: 0\n            },\n            improvements: {\n                totalLaborSaved: 0,\n                averageCycleTimeReduction: 0,\n                averageThroughputIncrease: 0,\n                jobBreakdown: []\n            }\n        };\n    }\n    // Calculate unique parts and total annual parts\n    const uniqueParts = jobs.reduce((sum, job)=>sum + job.parts.length, 0);\n    const totalAnnualParts = jobs.reduce((sum, job)=>sum + job.parts.reduce((jobSum, param)=>{\n            let { quantity } = param;\n            return jobSum + quantity * job.annualDemand;\n        }, 0), 0);\n    // Calculate metrics for each job\n    const jobMetrics = jobs.map((job)=>({\n            job,\n            metrics: calculateJobEfficiency(job)\n        }));\n    // Calculate shop-wide metrics\n    const manualTimes = jobMetrics.reduce((total, param)=>{\n        let { metrics } = param;\n        return {\n            totalWeldTime: total.totalWeldTime + metrics.manual.weldTime,\n            totalCycleTime: total.totalCycleTime + metrics.manual.totalCycleTime\n        };\n    }, {\n        totalWeldTime: 0,\n        totalCycleTime: 0\n    });\n    const cobotTimes = jobMetrics.reduce((total, param)=>{\n        let { metrics } = param;\n        return {\n            totalWeldTime: total.totalWeldTime + metrics.cobot.weldTime,\n            totalCycleTime: total.totalCycleTime + metrics.cobot.totalCycleTime\n        };\n    }, {\n        totalWeldTime: 0,\n        totalCycleTime: 0\n    });\n    const totalLaborSaved = (manualTimes.totalCycleTime - cobotTimes.totalCycleTime) / MINUTES_PER_HOUR;\n    // Calculate averages (only if there are jobs)\n    const averageCycleTimeReduction = jobMetrics.reduce((sum, param)=>{\n        let { metrics } = param;\n        return sum + metrics.improvements.cycleTimeReduction;\n    }, 0) / jobs.length;\n    const averageThroughputIncrease = jobMetrics.reduce((sum, param)=>{\n        let { metrics } = param;\n        return sum + metrics.improvements.throughputIncrease;\n    }, 0) / jobs.length;\n    return {\n        totalJobs: jobs.length,\n        uniqueParts,\n        totalAnnualParts,\n        manual: manualTimes,\n        cobot: cobotTimes,\n        improvements: {\n            totalLaborSaved: Math.max(0, totalLaborSaved),\n            averageCycleTimeReduction: Math.max(0, averageCycleTimeReduction),\n            averageThroughputIncrease: Math.max(0, averageThroughputIncrease),\n            jobBreakdown: jobMetrics.map((param)=>{\n                let { job, metrics } = param;\n                return {\n                    jobName: job.name,\n                    laborSaved: metrics.improvements.laborTimeSaved,\n                    cycleTimeReduction: metrics.improvements.cycleTimeReduction\n                };\n            })\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWMsR0FBRzRDLFdBQVc1QyxjQUFjLElBQUliO0lBRW5GLDhDQUE4QztJQUM5QyxNQUFNOEMsNEJBQTRCTSxXQUFXSCxNQUFNLENBQUMsQ0FBQ0M7WUFBSyxFQUFFSSxPQUFPLEVBQUU7ZUFDbkVKLE1BQU1JLFFBQVFyQixZQUFZLENBQUNILGtCQUFrQjtPQUFFLEtBQUtRLEtBQUtwQyxNQUFNO0lBRWpFLE1BQU02Qyw0QkFBNEJLLFdBQVdILE1BQU0sQ0FBQyxDQUFDQztZQUFLLEVBQUVJLE9BQU8sRUFBRTtlQUNuRUosTUFBTUksUUFBUXJCLFlBQVksQ0FBQ0Qsa0JBQWtCO09BQUUsS0FBS00sS0FBS3BDLE1BQU07SUFFakUsT0FBTztRQUNMdUMsV0FBV0gsS0FBS3BDLE1BQU07UUFDdEJ3QztRQUNBQztRQUNBaEMsUUFBUTRDO1FBQ1J6QyxPQUFPMkM7UUFDUHhCLGNBQWM7WUFDWlksaUJBQWlCWCxLQUFLQyxHQUFHLENBQUMsR0FBR1U7WUFDN0JDLDJCQUEyQlosS0FBS0MsR0FBRyxDQUFDLEdBQUdXO1lBQ3ZDQywyQkFBMkJiLEtBQUtDLEdBQUcsQ0FBQyxHQUFHWTtZQUN2Q0MsY0FBY0ksV0FBV0MsR0FBRyxDQUFDO29CQUFDLEVBQUUzQyxHQUFHLEVBQUU0QyxPQUFPLEVBQUU7dUJBQU07b0JBQ2xESSxTQUFTaEQsSUFBSW1CLElBQUk7b0JBQ2pCOEIsWUFBWUwsUUFBUXJCLFlBQVksQ0FBQ0YsY0FBYztvQkFDL0NELG9CQUFvQndCLFFBQVFyQixZQUFZLENBQUNILGtCQUFrQjtnQkFDN0Q7O1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvZXRoYW4vZGV2YmVkL3JvaS1jYWxjL3NyYy91dGlscy9qb2ItY2FsY3VsYXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdlbGRKb2IsIEpvYkVmZmljaWVuY3lNZXRyaWNzLCBUaW1lQnJlYWtkb3duIH0gZnJvbSAnQC90eXBlcy93ZWxkLWpvYnMnO1xuXG5jb25zdCBNSU5VVEVTX1BFUl9IT1VSID0gNjA7XG5cbmludGVyZmFjZSBKb2JCcmVha2Rvd24ge1xuICAgIGpvYk5hbWU6IHN0cmluZztcbiAgICBtYW51YWxUaW1lOiBudW1iZXI7ICAgICAgICAgLy8gbWludXRlcyBwZXIgam9iXG4gICAgY29ib3RUaW1lOiBudW1iZXI7ICAgICAgICAgIC8vIG1pbnV0ZXMgcGVyIGpvYlxuICAgIGxhYm9yU2F2ZWQ6IG51bWJlcjsgICAgICAgICAvLyBob3VycyBwZXIgeWVhclxuICAgIGN5Y2xlVGltZVJlZHVjdGlvbjogbnVtYmVyOyAvLyBwZXJjZW50YWdlXG4gIH1cbiAgXG5leHBvcnQgaW50ZXJmYWNlIFNob3BFZmZpY2llbmN5TWV0cmljcyB7XG4gICAgdG90YWxKb2JzOiBudW1iZXI7XG4gICAgdW5pcXVlUGFydHM6IG51bWJlcjtcbiAgICB0b3RhbEFubnVhbFBhcnRzOiBudW1iZXI7XG4gICAgbWFudWFsOiB7XG4gICAgICB0b3RhbFdlbGRUaW1lOiBudW1iZXI7ICAgICAvLyBtaW51dGVzIHBlciB5ZWFyXG4gICAgICB0b3RhbEN5Y2xlVGltZTogbnVtYmVyOyAgICAvLyBtaW51dGVzIHBlciB5ZWFyXG4gICAgfTtcbiAgICBjb2JvdDoge1xuICAgICAgdG90YWxXZWxkVGltZTogbnVtYmVyOyAgICAgLy8gbWludXRlcyBwZXIgeWVhclxuICAgICAgdG90YWxDeWNsZVRpbWU6IG51bWJlcjsgICAgLy8gbWludXRlcyBwZXIgeWVhclxuICAgIH07XG4gICAgaW1wcm92ZW1lbnRzOiB7XG4gICAgICB0b3RhbExhYm9yU2F2ZWQ6IG51bWJlcjsgICAgICAgICAgIC8vIGhvdXJzIHBlciB5ZWFyXG4gICAgICBhdmVyYWdlQ3ljbGVUaW1lUmVkdWN0aW9uOiBudW1iZXI7IC8vIHBlcmNlbnRhZ2VcbiAgICAgIGF2ZXJhZ2VUaHJvdWdocHV0SW5jcmVhc2U6IG51bWJlcjsgLy8gcGVyY2VudGFnZVxuICAgICAgam9iQnJlYWtkb3duOiBKb2JCcmVha2Rvd25bXTtcbiAgICB9O1xuICB9XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpbmdsZVBhcnRUaW1lKFxuICBsZW5ndGg6IG51bWJlcixcbiAgcGFzc2VzOiBudW1iZXIsXG4gIHRyYXZlbFNwZWVkOiBudW1iZXIsXG4gIGVmZmljaWVuY3k6IG51bWJlcixcbiAgaXNNYW51YWw6IGJvb2xlYW5cbik6IG51bWJlciB7XG4gIGlmICh0cmF2ZWxTcGVlZCA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1RyYXZlbCBzcGVlZCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gIGlmIChlZmZpY2llbmN5IDw9IDApIHRocm93IG5ldyBFcnJvcignRWZmaWNpZW5jeSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG5cbiAgY29uc3QgYmFzZVRpbWUgPSAobGVuZ3RoICogcGFzc2VzKSAvIHRyYXZlbFNwZWVkO1xuICByZXR1cm4gaXNNYW51YWwgPyBiYXNlVGltZSAvIChlZmZpY2llbmN5IC8gMTAwKSA6IGJhc2VUaW1lICogKGVmZmljaWVuY3kgLyAxMDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlSm9iRWZmaWNpZW5jeShqb2I6IFdlbGRKb2IpOiBKb2JFZmZpY2llbmN5TWV0cmljcyB7XG4gIGNvbnN0IG1hbnVhbDogVGltZUJyZWFrZG93biA9IHtcbiAgICB3ZWxkVGltZTogMCxcbiAgICB0b3RhbEN5Y2xlVGltZTogMFxuICB9O1xuXG4gIGNvbnN0IGNvYm90OiBUaW1lQnJlYWtkb3duID0ge1xuICAgIHdlbGRUaW1lOiAwLFxuICAgIHRvdGFsQ3ljbGVUaW1lOiAwXG4gIH07XG5cbiAgLy8gQ2FsY3VsYXRlIHRvdGFsIHRpbWUgZm9yIGVhY2ggcGFydFxuICBqb2IucGFydHMuZm9yRWFjaCgoeyBwYXJ0LCBxdWFudGl0eSB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aW1lIGZvciBvbmUgcGFydFxuICAgICAgY29uc3Qgc2luZ2xlUGFydE1hbnVhbFRpbWUgPSBjYWxjdWxhdGVTaW5nbGVQYXJ0VGltZShcbiAgICAgICAgcGFydC5sZW5ndGgsXG4gICAgICAgIHBhcnQucGFzc2VzLFxuICAgICAgICBwYXJ0Lm1hbnVhbFRyYXZlbFNwZWVkLFxuICAgICAgICBwYXJ0Lm1hbnVhbEVmZmljaWVuY3ksXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnN0IHNpbmdsZVBhcnRDb2JvdFRpbWUgPSBjYWxjdWxhdGVTaW5nbGVQYXJ0VGltZShcbiAgICAgICAgcGFydC5sZW5ndGgsXG4gICAgICAgIHBhcnQucGFzc2VzLFxuICAgICAgICBwYXJ0LmNvYm90VHJhdmVsU3BlZWQsXG4gICAgICAgIHBhcnQuY29ib3RFZmZpY2llbmN5LFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIGFubnVhbCB0aW1lIGZvciB0aGlzIHBhcnQgdHlwZVxuICAgICAgY29uc3QgdG90YWxQYXJ0c1BlclllYXIgPSBxdWFudGl0eSAqIGpvYi5hbm51YWxEZW1hbmQ7XG4gICAgICBtYW51YWwud2VsZFRpbWUgKz0gc2luZ2xlUGFydE1hbnVhbFRpbWUgKiB0b3RhbFBhcnRzUGVyWWVhcjtcbiAgICAgIGNvYm90LndlbGRUaW1lICs9IHNpbmdsZVBhcnRDb2JvdFRpbWUgKiB0b3RhbFBhcnRzUGVyWWVhcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY2FsY3VsYXRpbmcgdGltZXMgZm9yIHBhcnQgJHtwYXJ0Lm5hbWV9OmAsIGVycm9yKTtcbiAgICAgIC8vIENvbnRpbnVlIHdpdGggbmV4dCBwYXJ0IGluc3RlYWQgb2YgZmFpbGluZyBjb21wbGV0ZWx5XG4gICAgfVxuICB9KTtcblxuICAvLyBTZXQgdG90YWwgY3ljbGUgdGltZXMgKGN1cnJlbnRseSBqdXN0IHdlbGQgdGltZXMsIGNhbiBiZSBleHBhbmRlZClcbiAgbWFudWFsLnRvdGFsQ3ljbGVUaW1lID0gbWFudWFsLndlbGRUaW1lO1xuICBjb2JvdC50b3RhbEN5Y2xlVGltZSA9IGNvYm90LndlbGRUaW1lO1xuXG4gIC8vIENhbGN1bGF0ZSBpbXByb3ZlbWVudHMgKHdpdGggc2FmZXR5IGNoZWNrcylcbiAgY29uc3QgY3ljbGVUaW1lUmVkdWN0aW9uID0gbWFudWFsLnRvdGFsQ3ljbGVUaW1lID4gMCBcbiAgICA/ICgobWFudWFsLnRvdGFsQ3ljbGVUaW1lIC0gY29ib3QudG90YWxDeWNsZVRpbWUpIC8gbWFudWFsLnRvdGFsQ3ljbGVUaW1lKSAqIDEwMFxuICAgIDogMDtcblxuICBjb25zdCBsYWJvclRpbWVTYXZlZCA9IChtYW51YWwudG90YWxDeWNsZVRpbWUgLSBjb2JvdC50b3RhbEN5Y2xlVGltZSkgLyBNSU5VVEVTX1BFUl9IT1VSO1xuICBjb25zdCB0aHJvdWdocHV0SW5jcmVhc2UgPSBjb2JvdC50b3RhbEN5Y2xlVGltZSA+IDBcbiAgICA/ICgobWFudWFsLnRvdGFsQ3ljbGVUaW1lIC8gY29ib3QudG90YWxDeWNsZVRpbWUpIC0gMSkgKiAxMDBcbiAgICA6IDA7XG5cbiAgcmV0dXJuIHtcbiAgICBtYW51YWwsXG4gICAgY29ib3QsXG4gICAgaW1wcm92ZW1lbnRzOiB7XG4gICAgICBjeWNsZVRpbWVSZWR1Y3Rpb246IE1hdGgubWF4KDAsIGN5Y2xlVGltZVJlZHVjdGlvbiksXG4gICAgICBsYWJvclRpbWVTYXZlZDogTWF0aC5tYXgoMCwgbGFib3JUaW1lU2F2ZWQpLFxuICAgICAgdGhyb3VnaHB1dEluY3JlYXNlOiBNYXRoLm1heCgwLCB0aHJvdWdocHV0SW5jcmVhc2UpLFxuICAgICAgdG90YWxBbm51YWxTYXZpbmdzOiBNYXRoLm1heCgwLCBsYWJvclRpbWVTYXZlZClcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTaG9wRWZmaWNpZW5jeShqb2JzOiBXZWxkSm9iW10pOiBTaG9wRWZmaWNpZW5jeU1ldHJpY3Mge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoam9icykgfHwgam9icy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxKb2JzOiAwLFxuICAgICAgdW5pcXVlUGFydHM6IDAsXG4gICAgICB0b3RhbEFubnVhbFBhcnRzOiAwLFxuICAgICAgbWFudWFsOiB7IHRvdGFsV2VsZFRpbWU6IDAsIHRvdGFsQ3ljbGVUaW1lOiAwIH0sXG4gICAgICBjb2JvdDogeyB0b3RhbFdlbGRUaW1lOiAwLCB0b3RhbEN5Y2xlVGltZTogMCB9LFxuICAgICAgaW1wcm92ZW1lbnRzOiB7XG4gICAgICAgIHRvdGFsTGFib3JTYXZlZDogMCxcbiAgICAgICAgYXZlcmFnZUN5Y2xlVGltZVJlZHVjdGlvbjogMCxcbiAgICAgICAgYXZlcmFnZVRocm91Z2hwdXRJbmNyZWFzZTogMCxcbiAgICAgICAgam9iQnJlYWtkb3duOiBbXVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdW5pcXVlIHBhcnRzIGFuZCB0b3RhbCBhbm51YWwgcGFydHNcbiAgY29uc3QgdW5pcXVlUGFydHMgPSBqb2JzLnJlZHVjZSgoc3VtLCBqb2IpID0+IHN1bSArIGpvYi5wYXJ0cy5sZW5ndGgsIDApO1xuICBjb25zdCB0b3RhbEFubnVhbFBhcnRzID0gam9icy5yZWR1Y2UoKHN1bSwgam9iKSA9PiBcbiAgICBzdW0gKyBqb2IucGFydHMucmVkdWNlKChqb2JTdW0sIHsgcXVhbnRpdHkgfSkgPT4gXG4gICAgICBqb2JTdW0gKyAocXVhbnRpdHkgKiBqb2IuYW5udWFsRGVtYW5kKSwgMFxuICAgICksIDBcbiAgKTtcblxuICAvLyBDYWxjdWxhdGUgbWV0cmljcyBmb3IgZWFjaCBqb2JcbiAgY29uc3Qgam9iTWV0cmljcyA9IGpvYnMubWFwKGpvYiA9PiAoe1xuICAgIGpvYixcbiAgICBtZXRyaWNzOiBjYWxjdWxhdGVKb2JFZmZpY2llbmN5KGpvYilcbiAgfSkpO1xuXG4gIC8vIENhbGN1bGF0ZSBzaG9wLXdpZGUgbWV0cmljc1xuICBjb25zdCBtYW51YWxUaW1lcyA9IGpvYk1ldHJpY3MucmVkdWNlKCh0b3RhbCwgeyBtZXRyaWNzIH0pID0+ICh7XG4gICAgdG90YWxXZWxkVGltZTogdG90YWwudG90YWxXZWxkVGltZSArIG1ldHJpY3MubWFudWFsLndlbGRUaW1lLFxuICAgIHRvdGFsQ3ljbGVUaW1lOiB0b3RhbC50b3RhbEN5Y2xlVGltZSArIG1ldHJpY3MubWFudWFsLnRvdGFsQ3ljbGVUaW1lXG4gIH0pLCB7IHRvdGFsV2VsZFRpbWU6IDAsIHRvdGFsQ3ljbGVUaW1lOiAwIH0pO1xuXG4gIGNvbnN0IGNvYm90VGltZXMgPSBqb2JNZXRyaWNzLnJlZHVjZSgodG90YWwsIHsgbWV0cmljcyB9KSA9PiAoe1xuICAgIHRvdGFsV2VsZFRpbWU6IHRvdGFsLnRvdGFsV2VsZFRpbWUgKyBtZXRyaWNzLmNvYm90LndlbGRUaW1lLFxuICAgIHRvdGFsQ3ljbGVUaW1lOiB0b3RhbC50b3RhbEN5Y2xlVGltZSArIG1ldHJpY3MuY29ib3QudG90YWxDeWNsZVRpbWVcbiAgfSksIHsgdG90YWxXZWxkVGltZTogMCwgdG90YWxDeWNsZVRpbWU6IDAgfSk7XG5cbiAgY29uc3QgdG90YWxMYWJvclNhdmVkID0gKG1hbnVhbFRpbWVzLnRvdGFsQ3ljbGVUaW1lIC0gY29ib3RUaW1lcy50b3RhbEN5Y2xlVGltZSkgLyBNSU5VVEVTX1BFUl9IT1VSO1xuXG4gIC8vIENhbGN1bGF0ZSBhdmVyYWdlcyAob25seSBpZiB0aGVyZSBhcmUgam9icylcbiAgY29uc3QgYXZlcmFnZUN5Y2xlVGltZVJlZHVjdGlvbiA9IGpvYk1ldHJpY3MucmVkdWNlKChzdW0sIHsgbWV0cmljcyB9KSA9PiBcbiAgICBzdW0gKyBtZXRyaWNzLmltcHJvdmVtZW50cy5jeWNsZVRpbWVSZWR1Y3Rpb24sIDApIC8gam9icy5sZW5ndGg7XG5cbiAgY29uc3QgYXZlcmFnZVRocm91Z2hwdXRJbmNyZWFzZSA9IGpvYk1ldHJpY3MucmVkdWNlKChzdW0sIHsgbWV0cmljcyB9KSA9PiBcbiAgICBzdW0gKyBtZXRyaWNzLmltcHJvdmVtZW50cy50aHJvdWdocHV0SW5jcmVhc2UsIDApIC8gam9icy5sZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3RhbEpvYnM6IGpvYnMubGVuZ3RoLFxuICAgIHVuaXF1ZVBhcnRzLFxuICAgIHRvdGFsQW5udWFsUGFydHMsXG4gICAgbWFudWFsOiBtYW51YWxUaW1lcyxcbiAgICBjb2JvdDogY29ib3RUaW1lcyxcbiAgICBpbXByb3ZlbWVudHM6IHtcbiAgICAgIHRvdGFsTGFib3JTYXZlZDogTWF0aC5tYXgoMCwgdG90YWxMYWJvclNhdmVkKSxcbiAgICAgIGF2ZXJhZ2VDeWNsZVRpbWVSZWR1Y3Rpb246IE1hdGgubWF4KDAsIGF2ZXJhZ2VDeWNsZVRpbWVSZWR1Y3Rpb24pLFxuICAgICAgYXZlcmFnZVRocm91Z2hwdXRJbmNyZWFzZTogTWF0aC5tYXgoMCwgYXZlcmFnZVRocm91Z2hwdXRJbmNyZWFzZSksXG4gICAgICBqb2JCcmVha2Rvd246IGpvYk1ldHJpY3MubWFwKCh7IGpvYiwgbWV0cmljcyB9KSA9PiAoe1xuICAgICAgICBqb2JOYW1lOiBqb2IubmFtZSxcbiAgICAgICAgbGFib3JTYXZlZDogbWV0cmljcy5pbXByb3ZlbWVudHMubGFib3JUaW1lU2F2ZWQsXG4gICAgICAgIGN5Y2xlVGltZVJlZHVjdGlvbjogbWV0cmljcy5pbXByb3ZlbWVudHMuY3ljbGVUaW1lUmVkdWN0aW9uXG4gICAgICB9KSlcbiAgICB9XG4gIH07XG59Il0sIm5hbWVzIjpbIk1JTlVURVNfUEVSX0hPVVIiLCJjYWxjdWxhdGVTaW5nbGVQYXJ0VGltZSIsImxlbmd0aCIsInBhc3NlcyIsInRyYXZlbFNwZWVkIiwiZWZmaWNpZW5jeSIsImlzTWFudWFsIiwiRXJyb3IiLCJiYXNlVGltZSIsImNhbGN1bGF0ZUpvYkVmZmljaWVuY3kiLCJqb2IiLCJtYW51YWwiLCJ3ZWxkVGltZSIsInRvdGFsQ3ljbGVUaW1lIiwiY29ib3QiLCJwYXJ0cyIsImZvckVhY2giLCJwYXJ0IiwicXVhbnRpdHkiLCJzaW5nbGVQYXJ0TWFudWFsVGltZSIsIm1hbnVhbFRyYXZlbFNwZWVkIiwibWFudWFsRWZmaWNpZW5jeSIsInNpbmdsZVBhcnRDb2JvdFRpbWUiLCJjb2JvdFRyYXZlbFNwZWVkIiwiY29ib3RFZmZpY2llbmN5IiwidG90YWxQYXJ0c1BlclllYXIiLCJhbm51YWxEZW1hbmQiLCJlcnJvciIsImNvbnNvbGUiLCJuYW1lIiwiY3ljbGVUaW1lUmVkdWN0aW9uIiwibGFib3JUaW1lU2F2ZWQiLCJ0aHJvdWdocHV0SW5jcmVhc2UiLCJpbXByb3ZlbWVudHMiLCJNYXRoIiwibWF4IiwidG90YWxBbm51YWxTYXZpbmdzIiwiY2FsY3VsYXRlU2hvcEVmZmljaWVuY3kiLCJqb2JzIiwiQXJyYXkiLCJpc0FycmF5IiwidG90YWxKb2JzIiwidW5pcXVlUGFydHMiLCJ0b3RhbEFubnVhbFBhcnRzIiwidG90YWxXZWxkVGltZSIsInRvdGFsTGFib3JTYXZlZCIsImF2ZXJhZ2VDeWNsZVRpbWVSZWR1Y3Rpb24iLCJhdmVyYWdlVGhyb3VnaHB1dEluY3JlYXNlIiwiam9iQnJlYWtkb3duIiwicmVkdWNlIiwic3VtIiwiam9iU3VtIiwiam9iTWV0cmljcyIsIm1hcCIsIm1ldHJpY3MiLCJtYW51YWxUaW1lcyIsInRvdGFsIiwiY29ib3RUaW1lcyIsImpvYk5hbWUiLCJsYWJvclNhdmVkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/job-calculations.ts\n"));

/***/ })

});