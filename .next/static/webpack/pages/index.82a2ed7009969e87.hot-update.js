"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/utils/job-calculations.ts":
/*!***************************************!*\
  !*** ./src/utils/job-calculations.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateJobEfficiency: () => (/* binding */ calculateJobEfficiency),\n/* harmony export */   calculateShopEfficiency: () => (/* binding */ calculateShopEfficiency)\n/* harmony export */ });\nconst MINUTES_PER_HOUR = 60;\nfunction calculateSinglePartTime(length, passes, travelSpeed, efficiency, isManual) {\n    if (travelSpeed <= 0) throw new Error('Travel speed must be greater than 0');\n    if (efficiency <= 0) throw new Error('Efficiency must be greater than 0');\n    const baseTime = length * passes / travelSpeed;\n    return isManual ? baseTime / (efficiency / 100) : baseTime * (efficiency / 100);\n}\nfunction calculateJobEfficiency(job) {\n    const manual = {\n        weldTime: 0,\n        totalCycleTime: 0\n    };\n    const cobot = {\n        weldTime: 0,\n        totalCycleTime: 0\n    };\n    // Calculate total time for each part\n    job.parts.forEach((param)=>{\n        let { part, quantity } = param;\n        try {\n            // Calculate time for one part\n            const singlePartManualTime = calculateSinglePartTime(part.length, part.passes, part.manualTravelSpeed, part.manualEfficiency, true);\n            const singlePartCobotTime = calculateSinglePartTime(part.length, part.passes, part.cobotTravelSpeed, part.cobotEfficiency, false);\n            // Calculate total annual time for this part type\n            const totalPartsPerYear = quantity * job.annualDemand;\n            manual.weldTime += singlePartManualTime * totalPartsPerYear;\n            cobot.weldTime += singlePartCobotTime * totalPartsPerYear;\n        } catch (error) {\n            console.error(\"Error calculating times for part \".concat(part.name, \":\"), error);\n        // Continue with next part instead of failing completely\n        }\n    });\n    // Set total cycle times (currently just weld times, can be expanded)\n    manual.totalCycleTime = manual.weldTime;\n    cobot.totalCycleTime = cobot.weldTime;\n    // Calculate improvements (with safety checks)\n    const cycleTimeReduction = manual.totalCycleTime > 0 ? (manual.totalCycleTime - cobot.totalCycleTime) / manual.totalCycleTime * 100 : 0;\n    const laborTimeSaved = (manual.totalCycleTime - cobot.totalCycleTime) / MINUTES_PER_HOUR;\n    const throughputIncrease = cobot.totalCycleTime > 0 ? (manual.totalCycleTime / cobot.totalCycleTime - 1) * 100 : 0;\n    return {\n        manual,\n        cobot,\n        improvements: {\n            cycleTimeReduction: Math.max(0, cycleTimeReduction),\n            laborTimeSaved: Math.max(0, laborTimeSaved),\n            throughputIncrease: Math.max(0, throughputIncrease),\n            totalAnnualSavings: Math.max(0, laborTimeSaved)\n        }\n    };\n}\nfunction calculateShopEfficiency(jobs) {\n    if (!Array.isArray(jobs) || jobs.length === 0) {\n        return {\n            totalJobs: 0,\n            uniqueParts: 0,\n            totalAnnualParts: 0,\n            manual: {\n                totalWeldTime: 0,\n                totalCycleTime: 0\n            },\n            cobot: {\n                totalWeldTime: 0,\n                totalCycleTime: 0\n            },\n            improvements: {\n                totalLaborSaved: 0,\n                averageCycleTimeReduction: 0,\n                averageThroughputIncrease: 0,\n                jobBreakdown: []\n            }\n        };\n    }\n    // Calculate unique parts and total annual parts\n    const uniqueParts = jobs.reduce((sum, job)=>sum + job.parts.length, 0);\n    const totalAnnualParts = jobs.reduce((sum, job)=>sum + job.parts.reduce((jobSum, param)=>{\n            let { quantity } = param;\n            return jobSum + quantity * job.annualDemand;\n        }, 0), 0);\n    // Calculate metrics for each job\n    const jobMetrics = jobs.map((job)=>({\n            job,\n            metrics: calculateJobEfficiency(job)\n        }));\n    // Calculate shop-wide metrics\n    const manualTimes = jobMetrics.reduce((total, param)=>{\n        let { metrics } = param;\n        return {\n            totalWeldTime: total.totalWeldTime + metrics.manual.weldTime,\n            totalCycleTime: total.totalCycleTime + metrics.manual.totalCycleTime\n        };\n    }, {\n        totalWeldTime: 0,\n        totalCycleTime: 0\n    });\n    const cobotTimes = jobMetrics.reduce((total, param)=>{\n        let { metrics } = param;\n        return {\n            totalWeldTime: total.totalWeldTime + metrics.cobot.weldTime,\n            totalCycleTime: total.totalCycleTime + metrics.cobot.totalCycleTime\n        };\n    }, {\n        totalWeldTime: 0,\n        totalCycleTime: 0\n    });\n    const totalLaborSaved = (manualTimes.totalCycleTime - cobotTimes.totalCycleTime) / MINUTES_PER_HOUR;\n    // Calculate averages (only if there are jobs)\n    const averageCycleTimeReduction = jobMetrics.reduce((sum, param)=>{\n        let { metrics } = param;\n        return sum + metrics.improvements.cycleTimeReduction;\n    }, 0) / jobs.length;\n    const averageThroughputIncrease = jobMetrics.reduce((sum, param)=>{\n        let { metrics } = param;\n        return sum + metrics.improvements.throughputIncrease;\n    }, 0) / jobs.length;\n    return {\n        totalJobs: jobs.length,\n        uniqueParts,\n        totalAnnualParts,\n        manual: manualTimes,\n        cobot: cobotTimes,\n        improvements: {\n            totalLaborSaved: Math.max(0, totalLaborSaved),\n            averageCycleTimeReduction: Math.max(0, averageCycleTimeReduction),\n            averageThroughputIncrease: Math.max(0, averageThroughputIncrease),\n            jobBreakdown: jobMetrics.map((param)=>{\n                let { job, metrics } = param;\n                return {\n                    jobName: job.name,\n                    manualTime: metrics.manual.totalCycleTime,\n                    cobotTime: metrics.cobot.totalCycleTime,\n                    laborSaved: metrics.improvements.laborTimeSaved,\n                    cycleTimeReduction: metrics.improvements.cycleTimeReduction\n                };\n            })\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWMsR0FBRzRDLFdBQVc1QyxjQUFjLElBQUliO0lBRW5GLDhDQUE4QztJQUM5QyxNQUFNOEMsNEJBQTRCTSxXQUFXSCxNQUFNLENBQUMsQ0FBQ0M7WUFBSyxFQUFFSSxPQUFPLEVBQUU7ZUFDbkVKLE1BQU1JLFFBQVFyQixZQUFZLENBQUNILGtCQUFrQjtPQUFFLEtBQUtRLEtBQUtwQyxNQUFNO0lBRWpFLE1BQU02Qyw0QkFBNEJLLFdBQVdILE1BQU0sQ0FBQyxDQUFDQztZQUFLLEVBQUVJLE9BQU8sRUFBRTtlQUNuRUosTUFBTUksUUFBUXJCLFlBQVksQ0FBQ0Qsa0JBQWtCO09BQUUsS0FBS00sS0FBS3BDLE1BQU07SUFFL0QsT0FBTztRQUNIdUMsV0FBV0gsS0FBS3BDLE1BQU07UUFDdEJ3QztRQUNBQztRQUNBaEMsUUFBUTRDO1FBQ1J6QyxPQUFPMkM7UUFDUHhCLGNBQWM7WUFDWlksaUJBQWlCWCxLQUFLQyxHQUFHLENBQUMsR0FBR1U7WUFDN0JDLDJCQUEyQlosS0FBS0MsR0FBRyxDQUFDLEdBQUdXO1lBQ3ZDQywyQkFBMkJiLEtBQUtDLEdBQUcsQ0FBQyxHQUFHWTtZQUN2Q0MsY0FBY0ksV0FBV0MsR0FBRyxDQUFDO29CQUFDLEVBQUUzQyxHQUFHLEVBQUU0QyxPQUFPLEVBQUU7dUJBQU07b0JBQ2xESSxTQUFTaEQsSUFBSW1CLElBQUk7b0JBQ2pCOEIsWUFBWUwsUUFBUTNDLE1BQU0sQ0FBQ0UsY0FBYztvQkFDekMrQyxXQUFXTixRQUFReEMsS0FBSyxDQUFDRCxjQUFjO29CQUN2Q2dELFlBQVlQLFFBQVFyQixZQUFZLENBQUNGLGNBQWM7b0JBQy9DRCxvQkFBb0J3QixRQUFRckIsWUFBWSxDQUFDSCxrQkFBa0I7Z0JBQzdEOztRQUNGO0lBQ0Y7QUFDTiIsInNvdXJjZXMiOlsiL1VzZXJzL2V0aGFuL2RldmJlZC9yb2ktY2FsYy9zcmMvdXRpbHMvam9iLWNhbGN1bGF0aW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXZWxkSm9iLCBKb2JFZmZpY2llbmN5TWV0cmljcywgVGltZUJyZWFrZG93biB9IGZyb20gJ0AvdHlwZXMvd2VsZC1qb2JzJztcblxuY29uc3QgTUlOVVRFU19QRVJfSE9VUiA9IDYwO1xuXG5pbnRlcmZhY2UgSm9iQnJlYWtkb3duIHtcbiAgICBqb2JOYW1lOiBzdHJpbmc7XG4gICAgbWFudWFsVGltZTogbnVtYmVyOyAgICAgICAgIC8vIG1pbnV0ZXMgcGVyIGpvYlxuICAgIGNvYm90VGltZTogbnVtYmVyOyAgICAgICAgICAvLyBtaW51dGVzIHBlciBqb2JcbiAgICBsYWJvclNhdmVkOiBudW1iZXI7ICAgICAgICAgLy8gaG91cnMgcGVyIHllYXJcbiAgICBjeWNsZVRpbWVSZWR1Y3Rpb246IG51bWJlcjsgLy8gcGVyY2VudGFnZVxuICB9XG4gIFxuZXhwb3J0IGludGVyZmFjZSBTaG9wRWZmaWNpZW5jeU1ldHJpY3Mge1xuICAgIHRvdGFsSm9iczogbnVtYmVyO1xuICAgIHVuaXF1ZVBhcnRzOiBudW1iZXI7XG4gICAgdG90YWxBbm51YWxQYXJ0czogbnVtYmVyO1xuICAgIG1hbnVhbDoge1xuICAgICAgdG90YWxXZWxkVGltZTogbnVtYmVyOyAgICAgLy8gbWludXRlcyBwZXIgeWVhclxuICAgICAgdG90YWxDeWNsZVRpbWU6IG51bWJlcjsgICAgLy8gbWludXRlcyBwZXIgeWVhclxuICAgIH07XG4gICAgY29ib3Q6IHtcbiAgICAgIHRvdGFsV2VsZFRpbWU6IG51bWJlcjsgICAgIC8vIG1pbnV0ZXMgcGVyIHllYXJcbiAgICAgIHRvdGFsQ3ljbGVUaW1lOiBudW1iZXI7ICAgIC8vIG1pbnV0ZXMgcGVyIHllYXJcbiAgICB9O1xuICAgIGltcHJvdmVtZW50czoge1xuICAgICAgdG90YWxMYWJvclNhdmVkOiBudW1iZXI7ICAgICAgICAgICAvLyBob3VycyBwZXIgeWVhclxuICAgICAgYXZlcmFnZUN5Y2xlVGltZVJlZHVjdGlvbjogbnVtYmVyOyAvLyBwZXJjZW50YWdlXG4gICAgICBhdmVyYWdlVGhyb3VnaHB1dEluY3JlYXNlOiBudW1iZXI7IC8vIHBlcmNlbnRhZ2VcbiAgICAgIGpvYkJyZWFrZG93bjogSm9iQnJlYWtkb3duW107XG4gICAgfTtcbiAgfVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTaW5nbGVQYXJ0VGltZShcbiAgbGVuZ3RoOiBudW1iZXIsXG4gIHBhc3NlczogbnVtYmVyLFxuICB0cmF2ZWxTcGVlZDogbnVtYmVyLFxuICBlZmZpY2llbmN5OiBudW1iZXIsXG4gIGlzTWFudWFsOiBib29sZWFuXG4pOiBudW1iZXIge1xuICBpZiAodHJhdmVsU3BlZWQgPD0gMCkgdGhyb3cgbmV3IEVycm9yKCdUcmF2ZWwgc3BlZWQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICBpZiAoZWZmaWNpZW5jeSA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0VmZmljaWVuY3kgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuXG4gIGNvbnN0IGJhc2VUaW1lID0gKGxlbmd0aCAqIHBhc3NlcykgLyB0cmF2ZWxTcGVlZDtcbiAgcmV0dXJuIGlzTWFudWFsID8gYmFzZVRpbWUgLyAoZWZmaWNpZW5jeSAvIDEwMCkgOiBiYXNlVGltZSAqIChlZmZpY2llbmN5IC8gMTAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUpvYkVmZmljaWVuY3koam9iOiBXZWxkSm9iKTogSm9iRWZmaWNpZW5jeU1ldHJpY3Mge1xuICBjb25zdCBtYW51YWw6IFRpbWVCcmVha2Rvd24gPSB7XG4gICAgd2VsZFRpbWU6IDAsXG4gICAgdG90YWxDeWNsZVRpbWU6IDBcbiAgfTtcblxuICBjb25zdCBjb2JvdDogVGltZUJyZWFrZG93biA9IHtcbiAgICB3ZWxkVGltZTogMCxcbiAgICB0b3RhbEN5Y2xlVGltZTogMFxuICB9O1xuXG4gIC8vIENhbGN1bGF0ZSB0b3RhbCB0aW1lIGZvciBlYWNoIHBhcnRcbiAgam9iLnBhcnRzLmZvckVhY2goKHsgcGFydCwgcXVhbnRpdHkgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDYWxjdWxhdGUgdGltZSBmb3Igb25lIHBhcnRcbiAgICAgIGNvbnN0IHNpbmdsZVBhcnRNYW51YWxUaW1lID0gY2FsY3VsYXRlU2luZ2xlUGFydFRpbWUoXG4gICAgICAgIHBhcnQubGVuZ3RoLFxuICAgICAgICBwYXJ0LnBhc3NlcyxcbiAgICAgICAgcGFydC5tYW51YWxUcmF2ZWxTcGVlZCxcbiAgICAgICAgcGFydC5tYW51YWxFZmZpY2llbmN5LFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zdCBzaW5nbGVQYXJ0Q29ib3RUaW1lID0gY2FsY3VsYXRlU2luZ2xlUGFydFRpbWUoXG4gICAgICAgIHBhcnQubGVuZ3RoLFxuICAgICAgICBwYXJ0LnBhc3NlcyxcbiAgICAgICAgcGFydC5jb2JvdFRyYXZlbFNwZWVkLFxuICAgICAgICBwYXJ0LmNvYm90RWZmaWNpZW5jeSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBhbm51YWwgdGltZSBmb3IgdGhpcyBwYXJ0IHR5cGVcbiAgICAgIGNvbnN0IHRvdGFsUGFydHNQZXJZZWFyID0gcXVhbnRpdHkgKiBqb2IuYW5udWFsRGVtYW5kO1xuICAgICAgbWFudWFsLndlbGRUaW1lICs9IHNpbmdsZVBhcnRNYW51YWxUaW1lICogdG90YWxQYXJ0c1BlclllYXI7XG4gICAgICBjb2JvdC53ZWxkVGltZSArPSBzaW5nbGVQYXJ0Q29ib3RUaW1lICogdG90YWxQYXJ0c1BlclllYXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNhbGN1bGF0aW5nIHRpbWVzIGZvciBwYXJ0ICR7cGFydC5uYW1lfTpgLCBlcnJvcik7XG4gICAgICAvLyBDb250aW51ZSB3aXRoIG5leHQgcGFydCBpbnN0ZWFkIG9mIGZhaWxpbmcgY29tcGxldGVseVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gU2V0IHRvdGFsIGN5Y2xlIHRpbWVzIChjdXJyZW50bHkganVzdCB3ZWxkIHRpbWVzLCBjYW4gYmUgZXhwYW5kZWQpXG4gIG1hbnVhbC50b3RhbEN5Y2xlVGltZSA9IG1hbnVhbC53ZWxkVGltZTtcbiAgY29ib3QudG90YWxDeWNsZVRpbWUgPSBjb2JvdC53ZWxkVGltZTtcblxuICAvLyBDYWxjdWxhdGUgaW1wcm92ZW1lbnRzICh3aXRoIHNhZmV0eSBjaGVja3MpXG4gIGNvbnN0IGN5Y2xlVGltZVJlZHVjdGlvbiA9IG1hbnVhbC50b3RhbEN5Y2xlVGltZSA+IDAgXG4gICAgPyAoKG1hbnVhbC50b3RhbEN5Y2xlVGltZSAtIGNvYm90LnRvdGFsQ3ljbGVUaW1lKSAvIG1hbnVhbC50b3RhbEN5Y2xlVGltZSkgKiAxMDBcbiAgICA6IDA7XG5cbiAgY29uc3QgbGFib3JUaW1lU2F2ZWQgPSAobWFudWFsLnRvdGFsQ3ljbGVUaW1lIC0gY29ib3QudG90YWxDeWNsZVRpbWUpIC8gTUlOVVRFU19QRVJfSE9VUjtcbiAgY29uc3QgdGhyb3VnaHB1dEluY3JlYXNlID0gY29ib3QudG90YWxDeWNsZVRpbWUgPiAwXG4gICAgPyAoKG1hbnVhbC50b3RhbEN5Y2xlVGltZSAvIGNvYm90LnRvdGFsQ3ljbGVUaW1lKSAtIDEpICogMTAwXG4gICAgOiAwO1xuXG4gIHJldHVybiB7XG4gICAgbWFudWFsLFxuICAgIGNvYm90LFxuICAgIGltcHJvdmVtZW50czoge1xuICAgICAgY3ljbGVUaW1lUmVkdWN0aW9uOiBNYXRoLm1heCgwLCBjeWNsZVRpbWVSZWR1Y3Rpb24pLFxuICAgICAgbGFib3JUaW1lU2F2ZWQ6IE1hdGgubWF4KDAsIGxhYm9yVGltZVNhdmVkKSxcbiAgICAgIHRocm91Z2hwdXRJbmNyZWFzZTogTWF0aC5tYXgoMCwgdGhyb3VnaHB1dEluY3JlYXNlKSxcbiAgICAgIHRvdGFsQW5udWFsU2F2aW5nczogTWF0aC5tYXgoMCwgbGFib3JUaW1lU2F2ZWQpXG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU2hvcEVmZmljaWVuY3koam9iczogV2VsZEpvYltdKTogU2hvcEVmZmljaWVuY3lNZXRyaWNzIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGpvYnMpIHx8IGpvYnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsSm9iczogMCxcbiAgICAgIHVuaXF1ZVBhcnRzOiAwLFxuICAgICAgdG90YWxBbm51YWxQYXJ0czogMCxcbiAgICAgIG1hbnVhbDogeyB0b3RhbFdlbGRUaW1lOiAwLCB0b3RhbEN5Y2xlVGltZTogMCB9LFxuICAgICAgY29ib3Q6IHsgdG90YWxXZWxkVGltZTogMCwgdG90YWxDeWNsZVRpbWU6IDAgfSxcbiAgICAgIGltcHJvdmVtZW50czoge1xuICAgICAgICB0b3RhbExhYm9yU2F2ZWQ6IDAsXG4gICAgICAgIGF2ZXJhZ2VDeWNsZVRpbWVSZWR1Y3Rpb246IDAsXG4gICAgICAgIGF2ZXJhZ2VUaHJvdWdocHV0SW5jcmVhc2U6IDAsXG4gICAgICAgIGpvYkJyZWFrZG93bjogW11cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHVuaXF1ZSBwYXJ0cyBhbmQgdG90YWwgYW5udWFsIHBhcnRzXG4gIGNvbnN0IHVuaXF1ZVBhcnRzID0gam9icy5yZWR1Y2UoKHN1bSwgam9iKSA9PiBzdW0gKyBqb2IucGFydHMubGVuZ3RoLCAwKTtcbiAgY29uc3QgdG90YWxBbm51YWxQYXJ0cyA9IGpvYnMucmVkdWNlKChzdW0sIGpvYikgPT4gXG4gICAgc3VtICsgam9iLnBhcnRzLnJlZHVjZSgoam9iU3VtLCB7IHF1YW50aXR5IH0pID0+IFxuICAgICAgam9iU3VtICsgKHF1YW50aXR5ICogam9iLmFubnVhbERlbWFuZCksIDBcbiAgICApLCAwXG4gICk7XG5cbiAgLy8gQ2FsY3VsYXRlIG1ldHJpY3MgZm9yIGVhY2ggam9iXG4gIGNvbnN0IGpvYk1ldHJpY3MgPSBqb2JzLm1hcChqb2IgPT4gKHtcbiAgICBqb2IsXG4gICAgbWV0cmljczogY2FsY3VsYXRlSm9iRWZmaWNpZW5jeShqb2IpXG4gIH0pKTtcblxuICAvLyBDYWxjdWxhdGUgc2hvcC13aWRlIG1ldHJpY3NcbiAgY29uc3QgbWFudWFsVGltZXMgPSBqb2JNZXRyaWNzLnJlZHVjZSgodG90YWwsIHsgbWV0cmljcyB9KSA9PiAoe1xuICAgIHRvdGFsV2VsZFRpbWU6IHRvdGFsLnRvdGFsV2VsZFRpbWUgKyBtZXRyaWNzLm1hbnVhbC53ZWxkVGltZSxcbiAgICB0b3RhbEN5Y2xlVGltZTogdG90YWwudG90YWxDeWNsZVRpbWUgKyBtZXRyaWNzLm1hbnVhbC50b3RhbEN5Y2xlVGltZVxuICB9KSwgeyB0b3RhbFdlbGRUaW1lOiAwLCB0b3RhbEN5Y2xlVGltZTogMCB9KTtcblxuICBjb25zdCBjb2JvdFRpbWVzID0gam9iTWV0cmljcy5yZWR1Y2UoKHRvdGFsLCB7IG1ldHJpY3MgfSkgPT4gKHtcbiAgICB0b3RhbFdlbGRUaW1lOiB0b3RhbC50b3RhbFdlbGRUaW1lICsgbWV0cmljcy5jb2JvdC53ZWxkVGltZSxcbiAgICB0b3RhbEN5Y2xlVGltZTogdG90YWwudG90YWxDeWNsZVRpbWUgKyBtZXRyaWNzLmNvYm90LnRvdGFsQ3ljbGVUaW1lXG4gIH0pLCB7IHRvdGFsV2VsZFRpbWU6IDAsIHRvdGFsQ3ljbGVUaW1lOiAwIH0pO1xuXG4gIGNvbnN0IHRvdGFsTGFib3JTYXZlZCA9IChtYW51YWxUaW1lcy50b3RhbEN5Y2xlVGltZSAtIGNvYm90VGltZXMudG90YWxDeWNsZVRpbWUpIC8gTUlOVVRFU19QRVJfSE9VUjtcblxuICAvLyBDYWxjdWxhdGUgYXZlcmFnZXMgKG9ubHkgaWYgdGhlcmUgYXJlIGpvYnMpXG4gIGNvbnN0IGF2ZXJhZ2VDeWNsZVRpbWVSZWR1Y3Rpb24gPSBqb2JNZXRyaWNzLnJlZHVjZSgoc3VtLCB7IG1ldHJpY3MgfSkgPT4gXG4gICAgc3VtICsgbWV0cmljcy5pbXByb3ZlbWVudHMuY3ljbGVUaW1lUmVkdWN0aW9uLCAwKSAvIGpvYnMubGVuZ3RoO1xuXG4gIGNvbnN0IGF2ZXJhZ2VUaHJvdWdocHV0SW5jcmVhc2UgPSBqb2JNZXRyaWNzLnJlZHVjZSgoc3VtLCB7IG1ldHJpY3MgfSkgPT4gXG4gICAgc3VtICsgbWV0cmljcy5pbXByb3ZlbWVudHMudGhyb3VnaHB1dEluY3JlYXNlLCAwKSAvIGpvYnMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG90YWxKb2JzOiBqb2JzLmxlbmd0aCxcbiAgICAgICAgdW5pcXVlUGFydHMsXG4gICAgICAgIHRvdGFsQW5udWFsUGFydHMsXG4gICAgICAgIG1hbnVhbDogbWFudWFsVGltZXMsXG4gICAgICAgIGNvYm90OiBjb2JvdFRpbWVzLFxuICAgICAgICBpbXByb3ZlbWVudHM6IHtcbiAgICAgICAgICB0b3RhbExhYm9yU2F2ZWQ6IE1hdGgubWF4KDAsIHRvdGFsTGFib3JTYXZlZCksXG4gICAgICAgICAgYXZlcmFnZUN5Y2xlVGltZVJlZHVjdGlvbjogTWF0aC5tYXgoMCwgYXZlcmFnZUN5Y2xlVGltZVJlZHVjdGlvbiksXG4gICAgICAgICAgYXZlcmFnZVRocm91Z2hwdXRJbmNyZWFzZTogTWF0aC5tYXgoMCwgYXZlcmFnZVRocm91Z2hwdXRJbmNyZWFzZSksXG4gICAgICAgICAgam9iQnJlYWtkb3duOiBqb2JNZXRyaWNzLm1hcCgoeyBqb2IsIG1ldHJpY3MgfSkgPT4gKHtcbiAgICAgICAgICAgIGpvYk5hbWU6IGpvYi5uYW1lLFxuICAgICAgICAgICAgbWFudWFsVGltZTogbWV0cmljcy5tYW51YWwudG90YWxDeWNsZVRpbWUsXG4gICAgICAgICAgICBjb2JvdFRpbWU6IG1ldHJpY3MuY29ib3QudG90YWxDeWNsZVRpbWUsXG4gICAgICAgICAgICBsYWJvclNhdmVkOiBtZXRyaWNzLmltcHJvdmVtZW50cy5sYWJvclRpbWVTYXZlZCxcbiAgICAgICAgICAgIGN5Y2xlVGltZVJlZHVjdGlvbjogbWV0cmljcy5pbXByb3ZlbWVudHMuY3ljbGVUaW1lUmVkdWN0aW9uXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH07XG59Il0sIm5hbWVzIjpbIk1JTlVURVNfUEVSX0hPVVIiLCJjYWxjdWxhdGVTaW5nbGVQYXJ0VGltZSIsImxlbmd0aCIsInBhc3NlcyIsInRyYXZlbFNwZWVkIiwiZWZmaWNpZW5jeSIsImlzTWFudWFsIiwiRXJyb3IiLCJiYXNlVGltZSIsImNhbGN1bGF0ZUpvYkVmZmljaWVuY3kiLCJqb2IiLCJtYW51YWwiLCJ3ZWxkVGltZSIsInRvdGFsQ3ljbGVUaW1lIiwiY29ib3QiLCJwYXJ0cyIsImZvckVhY2giLCJwYXJ0IiwicXVhbnRpdHkiLCJzaW5nbGVQYXJ0TWFudWFsVGltZSIsIm1hbnVhbFRyYXZlbFNwZWVkIiwibWFudWFsRWZmaWNpZW5jeSIsInNpbmdsZVBhcnRDb2JvdFRpbWUiLCJjb2JvdFRyYXZlbFNwZWVkIiwiY29ib3RFZmZpY2llbmN5IiwidG90YWxQYXJ0c1BlclllYXIiLCJhbm51YWxEZW1hbmQiLCJlcnJvciIsImNvbnNvbGUiLCJuYW1lIiwiY3ljbGVUaW1lUmVkdWN0aW9uIiwibGFib3JUaW1lU2F2ZWQiLCJ0aHJvdWdocHV0SW5jcmVhc2UiLCJpbXByb3ZlbWVudHMiLCJNYXRoIiwibWF4IiwidG90YWxBbm51YWxTYXZpbmdzIiwiY2FsY3VsYXRlU2hvcEVmZmljaWVuY3kiLCJqb2JzIiwiQXJyYXkiLCJpc0FycmF5IiwidG90YWxKb2JzIiwidW5pcXVlUGFydHMiLCJ0b3RhbEFubnVhbFBhcnRzIiwidG90YWxXZWxkVGltZSIsInRvdGFsTGFib3JTYXZlZCIsImF2ZXJhZ2VDeWNsZVRpbWVSZWR1Y3Rpb24iLCJhdmVyYWdlVGhyb3VnaHB1dEluY3JlYXNlIiwiam9iQnJlYWtkb3duIiwicmVkdWNlIiwic3VtIiwiam9iU3VtIiwiam9iTWV0cmljcyIsIm1hcCIsIm1ldHJpY3MiLCJtYW51YWxUaW1lcyIsInRvdGFsIiwiY29ib3RUaW1lcyIsImpvYk5hbWUiLCJtYW51YWxUaW1lIiwiY29ib3RUaW1lIiwibGFib3JTYXZlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/job-calculations.ts\n"));

/***/ })

});